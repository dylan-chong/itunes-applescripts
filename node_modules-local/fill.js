const fs = require('fs');
const log = require('./header-log.js').log;

// Matches '/* @fill a-keyword */'
const FILL_REGEX = /\/\*[ ]*@fill[ ]+[^ \*]+[ ]*\*\//g;

exports.getFilledString = getFilledString;

function getFilledString(templateObject, replacementsDictionary) {
  var template = getDataFromFileContentsObject(templateObject);
  var replacements = getReplacements(replacementsDictionary);

  var filledString = getFilledString(template, replacements);
  log('filledString', 0, filledString);
  return filledString;

  function getDataFromFileContentsObject(object) {
    return object.contents || fs.readFileSync(
        object.path, {encoding: 'utf8'});
  }

  function getReplacements(replacementsDictionary) {
    var r = {};
    for (var key in replacementsDictionary) {
      r[key] = getDataFromFileContentsObject(replacementsDictionary[key]);
    }
    return r;
  }

  function getFilledString(template, replacements) {
    var splitByFillComments = template.split(FILL_REGEX);

    var fillContents = getFillContents(template, replacements);
    log('fillContents', 0, fillContents);

    // TODO join the splitByFillComments with the fillContents

    function getFillContents(template, replacements) {
      var fillCommentArguments = getFillCommentArguments(template);

      // TODO go through replacements and see if they match the fill comment arguments

      function getFillCommentArguments(template) {
        var fillComments = template.match(FILL_REGEX);
        var arguments = []; // Note: There is only one arg per fillComment
        for (var a = 0; a < fillComments.length; a++) {
          var words = fillComments[a].split(/[ ]+/);
          arguments[a] = words[words.indexOf('@fill') + 1];
          log('arguments[' + a + '] = ', 2, arguments[a]);
        }
      }
    }
  }
}

